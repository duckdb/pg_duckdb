-- <JSON_EXISTS>
-- Test 1: Path exists in a simple JSON object
SELECT json_exists('{"a": {"b": 1}}'::json, '$.a.b'); -- Expected: true
 json_exists 
-------------
 t
(1 row)

-- Test 2: Path does not exist in a simple JSON object
SELECT json_exists('{"a": {"b": 1}}'::json, '$.a.c'); -- Expected: false
 json_exists 
-------------
 f
(1 row)

-- </JSON_EXISTS>
-- <JSON_EXTRACT>
-- Basic JSON Extraction
SELECT json_extract('{"key": "value"}'::json, '$.key') AS result; -- Expected: "value"
 result  
---------
 "value"
(1 row)

-- Nested JSON Extraction
SELECT json_extract('{"a": {"b": {"c": 42}}}'::json, '$.a.b.c') AS result; -- Expected: 42
 result 
--------
 42
(1 row)

-- Multiple paths to nested objects
SELECT json_extract('{"a": {"b": {"c": 42}}, "x": {"y": "value"}}'::json, ARRAY['$.a.b.c', '$.x.y']) AS result; -- Expected: [42, "value"]
      result      
------------------
 {42,"\"value\""}
(1 row)

-- </JSON_EXTRACT>
-- <JSON_EXTRACT_STRING>
-- Basic JSON Extraction
SELECT json_extract_string('{"key": "value"}'::json, '$.key') AS result; -- Expected: "value"
 result 
--------
 value
(1 row)

-- Nested JSON Extraction
SELECT json_extract_string('{"a": {"b": {"c": 42}}}'::json, '$.a.b.c') AS result; -- Expected: 42
 result 
--------
 42
(1 row)

-- Multiple paths to nested objects
SELECT json_extract_string('{"a": {"b": {"c": 42}}, "x": {"y": "value"}}'::json, ARRAY['$.a.b.c', '$.x.y']) AS result; -- Expected: [42, "value"]
   result   
------------
 {42,value}
(1 row)

-- </JSON_EXTRACT_STRING>
-- Boolean and Numeric Values
SELECT json_extract_string('{"key": true}'::json, '$.key') AS result; -- Expected: true
 result 
--------
 true
(1 row)

SELECT json_extract_string('{"key": 123}'::json, '$.key') AS result; -- Expected: 123
 result 
--------
 123
(1 row)

-- </JSON_EXTRACT_STRING>
-- <JSON_VALUE>
-- Basic Scalar Value Extraction
SELECT json_value('{"key": "value"}'::json, '$.key') AS result; -- Expected: "value"
 result  
---------
 "value"
(1 row)

-- Nested JSON Extraction
SELECT json_value('{"a": {"b": {"c": 42}}}'::json, '$.a.b.c') AS result; -- Expected: 42
 result 
--------
 42
(1 row)

-- Non-existent Path
SELECT json_value('{"key": "value"}'::json, '$.nonexistent') AS result; -- Expected: NULL
 result 
--------
 
(1 row)

-- </JSON_VALUE>
-- <JSON_ARRAY_LENGTH>
-- Test with a JSON array at the root and using a JSON path
SELECT json_array_length('[1, 2, 3, 4, 5]'::json, '$') AS array_length; -- Expected: 5
 array_length 
--------------
            5
(1 row)

-- Test with a JSON object that doesn't contain an array at the path
SELECT json_array_length('{"not_an_array": {"key": "value"}}'::json, '$.not_an_array') AS array_length; -- Expected: Error or NULL
 array_length 
--------------
            0
(1 row)

-- </JSON_ARRAY_LENGTH>
-- <JSON_CONTAINS>
-- Simple JSON array with numeric needle
SELECT json_contains('[1, 2, 3, 4]'::json, '2') AS contains_numeric; -- Expected: TRUE
 contains_numeric 
------------------
 t
(1 row)

-- JSON object containing the needle as a value
SELECT json_contains('{"key1": "value1", "key2": 42}'::json, '"value1"') AS contains_object_value; -- Expected: TRUE
 contains_object_value 
-----------------------
 t
(1 row)

-- </JSON_CONTAINS>
-- <JSON_Keys>
-- Test 1: Extract keys from a simple JSON object
SELECT json_keys('{"key1": "value1", "key2": "value2", "key3": "value3"}'::JSON);
    json_keys     
------------------
 {key1,key2,key3}
(1 row)

-- Test 2: Extract keys from an empty JSON object
SELECT json_keys('{}'::JSON);
 json_keys 
-----------
 {}
(1 row)

-- </JSON_Keys>
-- <JSON_STRUCTURE>
-- Test 1: Consistent structure (simple nested JSON object)
SELECT json_structure('{"name": "John", "age": 30, "address": {"city": "New York", "zip": "10001"}}'::JSON)
AS structure;
                                    structure                                    
---------------------------------------------------------------------------------
 {"name":"VARCHAR","age":"UBIGINT","address":{"city":"VARCHAR","zip":"VARCHAR"}}
(1 row)

-- Expected Output:
-- { "name": "string", "age": "number", "address": { "city": "string", "zip": "string" } }
-- Test 2: Inconsistent structure (array with incompatible types)
SELECT json_structure('{"data": [1, "string", {"key": "value"}]}'::JSON)
AS structure;
     structure     
-------------------
 {"data":["JSON"]}
(1 row)

-- Expected Output:
-- JSON (due to inconsistent types in the array)
-- </JSON_STRUCTURE>
-- <JSON_TYPE>
-- Test 1: Determine the type of the top-level JSON
SELECT json_type('{"name": "John", "age": 30, "isEmployed": true, "skills": ["SQL", "Python"]}'::JSON)
AS top_level_type;
 top_level_type 
----------------
 OBJECT
(1 row)

-- Expected Output:
-- OBJECT (because the top-level JSON is an object)
-- Test 2: Determine the types of elements at specific paths
SELECT json_type('{"name": "John", "age": 30, "isEmployed": true, "skills": ["SQL", "Python"]}'::JSON, ARRAY['name', 'age', 'isEmployed', 'skills'])
AS element_types;
          element_types          
---------------------------------
 {VARCHAR,UBIGINT,BOOLEAN,ARRAY}
(1 row)

-- Expected Output:
-- LIST ['VARCHAR', 'BIGINT', 'BOOLEAN', 'ARRAY'] (corresponding to the types of the specified elements)
-- </JSON_TYPE>
-- <JSON_VALID>
-- Test 1: Valid JSON
SELECT json_valid('{"name": "John", "age": 30, "skills": ["SQL", "Python"]}'::JSON) AS is_valid;
 is_valid 
----------
 t
(1 row)

-- Expected Output:
-- true (since the JSON is well-formed)
-- Test 2: Invalid JSON
SELECT json_valid('{"name": "John", "age": 30, "skills": ["SQL", "Python"::JSON) AS is_valid;

-- Expected Output:
-- false (since the JSON is not well-formed; missing closing bracket in the array)

-- </JSON_VALID>
ERROR:  unterminated quoted string at or near "'{"name": "John", "age": 30, "skills": ["SQL", "Python"::JSON) AS is_valid;

-- Expected Output:
-- false (since the JSON is not well-formed; missing closing bracket in the array)

-- </JSON_VALID>"
LINE 1: SELECT json_valid('{"name": "John", "age": 30, "skills": ["S...
                          ^
