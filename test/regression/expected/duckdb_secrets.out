-- Invalid type
CREATE SERVER invalid_duckdb_server
TYPE 'unknown'
FOREIGN DATA WRAPPER duckdb;
ERROR:  Secret type 'unknown' not found
-- Invalid use of restricted option (with various casing)
CREATE SERVER invalid_duckdb_server
TYPE 's3'
FOREIGN DATA WRAPPER duckdb
OPTIONS (tOkeN 'very secret');
ERROR:  Option 'token' cannot be used in the SERVER's OPTIONS, please move it to the USER MAPPING
CREATE SERVER invalid_duckdb_server
TYPE 's3'
FOREIGN DATA WRAPPER duckdb
OPTIONS (SECRET 'dont leak me');
ERROR:  Option 'secret' cannot be used in the SERVER's OPTIONS, please move it to the USER MAPPING
CREATE SERVER invalid_duckdb_server
TYPE 's3'
FOREIGN DATA WRAPPER duckdb
OPTIONS (session_TOKEN 'shhhhh');
ERROR:  Option 'session_token' cannot be used in the SERVER's OPTIONS, please move it to the USER MAPPING
CREATE SERVER invalid_duckdb_server
TYPE 'azure'
FOREIGN DATA WRAPPER duckdb
OPTIONS (CONNECTION_STRING 'all my life secrets here');
ERROR:  Option 'connection_string' cannot be used in the SERVER's OPTIONS, please move it to the USER MAPPING
-- No secret was created
SELECT * FROM duckdb.query($$ SELECT count(*) FROM duckdb_secrets(); $$);
 count_star() 
--------------
            0
(1 row)

-- Valid S3
CREATE SERVER valid_s3_server
TYPE 's3'
FOREIGN DATA WRAPPER duckdb;
-- Secret was created
SELECT * FROM duckdb.query($$ FROM which_secret('s3://some-bucket/file.parquet', 's3'); $$);
              name               | persistent | storage 
---------------------------------+------------+---------
 pgduckdb_secret_valid_s3_server | TEMPORARY  | memory
(1 row)

-- Valid secrets for other types (don't load Azure or other extensions)
CREATE SERVER valid_r2_server TYPE 'r2' FOREIGN DATA WRAPPER duckdb;
CREATE SERVER valid_hf_server TYPE 'huggingface' FOREIGN DATA WRAPPER duckdb;
CREATE SERVER valid_gcs_server TYPE 'gcs' FOREIGN DATA WRAPPER duckdb;
-- Check them all
SELECT * FROM duckdb.query($$ SELECT name, type FROM duckdb_secrets(); $$);
               name               |    type     
----------------------------------+-------------
 pgduckdb_secret_valid_gcs_server | gcs
 pgduckdb_secret_valid_hf_server  | huggingface
 pgduckdb_secret_valid_r2_server  | r2
 pgduckdb_secret_valid_s3_server  | s3
(4 rows)

-- Add one more (test drop & recreate)
CREATE SERVER valid_http_server TYPE 'http' FOREIGN DATA WRAPPER duckdb;
-- And verify we have them all
SELECT * FROM duckdb.query($$ SELECT name, type FROM duckdb_secrets(); $$);
               name                |    type     
-----------------------------------+-------------
 pgduckdb_secret_valid_gcs_server  | gcs
 pgduckdb_secret_valid_hf_server   | huggingface
 pgduckdb_secret_valid_http_server | http
 pgduckdb_secret_valid_r2_server   | r2
 pgduckdb_secret_valid_s3_server   | s3
(5 rows)

-- PROVIDER option needs the `aws` extension
SELECT duckdb.install_extension('aws');
 install_extension 
-------------------
 
(1 row)

CREATE SERVER valid_s3_cred_chain
TYPE 's3'
FOREIGN DATA WRAPPER duckdb
OPTIONS (PROVIDER 'credential_chain', CHAIN ''); -- use empty chain otherwise it takes too much time
-- Drop some
DROP SERVER valid_r2_server;
DROP SERVER valid_hf_server;
DROP SERVER valid_gcs_server;
DROP SERVER valid_http_server;
-- Make sure we have the 'credential_chain'
SELECT * FROM duckdb.query($$
    SELECT
        name,
        map_from_entries(
            list_transform( -- split 'key=value' strings to have an array of [key, value]
            list_transform( -- split the secret string by `;` to have 'key=value' strings
                regexp_split_to_array(secret_string, ';'),
                x -> regexp_split_to_array(x, '=')
            ),
            x -> struct_pack(k := x[1], v := x[2])
            )
        ).provider as provider
    FROM duckdb_secrets();
$$);
                name                 |     provider     
-------------------------------------+------------------
 pgduckdb_secret_valid_s3_cred_chain | credential_chain
 pgduckdb_secret_valid_s3_server     | config
(2 rows)

DROP SERVER valid_s3_server;
DROP SERVER valid_s3_cred_chain;
-- Nothing
SELECT * FROM duckdb.query($$ SELECT name, type FROM duckdb_secrets(); $$);
 name | type 
------+------
(0 rows)

-- Now create secrets with USER MAPPING
CREATE SERVER valid_s3_server TYPE 's3' FOREIGN DATA WRAPPER duckdb;
CREATE USER MAPPING FOR CURRENT_USER
SERVER valid_s3_server
OPTIONS (KEY_ID 'my_secret_key', SECRET 'my_secret_value');
SELECT * FROM duckdb.query($$
    SELECT
        name,
        secrets.key_id,
        secrets.secret
    FROM (
        SELECT
            name,
            map_from_entries(list_transform(list_transform(regexp_split_to_array(secret_string, ';'),x -> regexp_split_to_array(x, '=')),x -> struct_pack(k := x[1], v := x[2]))) as secrets
        FROM duckdb_secrets()
    );
$$);
                name                |    key_id     |  secret  
------------------------------------+---------------+----------
 pgduckdb_secret_valid_s3_server_10 | my_secret_key | redacted
(1 row)

SET client_min_messages=WARNING; -- suppress NOTICE that include username
DROP SERVER valid_s3_server CASCADE;
-- Nothing
SELECT * FROM duckdb.query($$ SELECT name, type FROM duckdb_secrets(); $$);
 name | type 
------+------
(0 rows)

